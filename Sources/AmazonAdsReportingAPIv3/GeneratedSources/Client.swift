// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import struct Foundation.URL
@preconcurrency import struct Foundation.Data
@preconcurrency import struct Foundation.Date
#else
import struct Foundation.URL
import struct Foundation.Data
import struct Foundation.Date
#endif
import HTTPTypes
public struct Client: APIProtocol {
    /// The underlying HTTP client.
    private let client: UniversalClient
    /// Creates a new client.
    /// - Parameters:
    ///   - serverURL: The server URL that the client connects to. Any server
    ///   URLs defined in the OpenAPI document are available as static methods
    ///   on the ``Servers`` type.
    ///   - configuration: A set of configuration values for the client.
    ///   - transport: A transport that performs HTTP operations.
    ///   - middlewares: A list of middlewares to call before the transport.
    public init(
        serverURL: Foundation.URL,
        configuration: Configuration = .init(),
        transport: any ClientTransport,
        middlewares: [any ClientMiddleware] = []
    ) {
        self.client = .init(
            serverURL: serverURL,
            configuration: configuration,
            transport: transport,
            middlewares: middlewares
        )
    }
    private var converter: Converter {
        client.converter
    }
    /// Creates a report request
    ///
    /// Creates a report request. Use this operation to request the creation of a new report for Amazon Advertising Products. Use `adProduct` to specify the Advertising Product of the report.
    ///
    /// **Authorized resource type**:
    /// Global Ad Account ID, Profile ID
    ///
    /// **Parameter name**:
    /// Amazon-Advertising-API-Scope
    ///
    /// **Parameter in**:
    /// header
    ///
    /// **Requires one of these permissions**:
    /// ["advertiser_campaign_edit","advertiser_campaign_view","nemo_report_edit","nemo_report_view","reports_edit"]
    ///
    /// **Authorized resource type**:
    /// DSP Rodeo Entity ID, DSP Advertiser Account ID
    ///
    /// **Parameter name**:
    /// Amazon-Ads-AccountId
    ///
    /// **Parameter in**:
    /// header
    ///
    /// **Requires one of these permissions**:
    /// ["advertiser_campaign_edit","advertiser_campaign_view","nemo_report_edit","nemo_report_view","reports_edit","view_performance_dashboard"]
    ///
    /// - Remark: HTTP `POST /reporting/reports`.
    /// - Remark: Generated from `#/paths//reporting/reports/post(createAsyncReport)`.
    public func createAsyncReport(_ input: Operations.createAsyncReport.Input) async throws -> Operations.createAsyncReport.Output {
        try await client.send(
            input: input,
            forOperation: Operations.createAsyncReport.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/reporting/reports",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "Amazon-Advertising-API-ClientId",
                    value: input.headers.Amazon_hyphen_Advertising_hyphen_API_hyphen_ClientId
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "Amazon-Advertising-API-Scope",
                    value: input.headers.Amazon_hyphen_Advertising_hyphen_API_hyphen_Scope
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "Amazon-Ads-AccountId",
                    value: input.headers.Amazon_hyphen_Ads_hyphen_AccountId
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case .none:
                    body = nil
                case let .application_vnd_period_createasyncreportrequest_period_v3_plus_json(value):
                    body = try converter.setOptionalRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/vnd.createasyncreportrequest.v3+json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.createAsyncReport.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/vnd.createasyncreportresponse.v3+json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/vnd.createasyncreportresponse.v3+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AsyncReport.self,
                            from: responseBody,
                            transforming: { value in
                                .application_vnd_period_createasyncreportresponse_period_v3_plus_json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.createAsyncReport.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AsyncReportingError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 401:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.createAsyncReport.Output.Unauthorized.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AsyncReportingError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unauthorized(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.createAsyncReport.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AsyncReportingError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                case 425:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.createAsyncReport.Output.TooEarly.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AsyncReportingError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .tooEarly(.init(body: body))
                case 429:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.createAsyncReport.Output.TooManyRequests.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AsyncReportingError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .tooManyRequests(.init(body: body))
                case 500:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.createAsyncReport.Output.InternalServerError.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AsyncReportingError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .internalServerError(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a generation status of report by id
    ///
    /// Gets a generation status of a report by id. Uses the `reportId` value from
    /// the response of previously requested report via `POST /reporting/reports`
    /// operation. When `status` is set to `COMPLETED`, the report will be
    /// available to be downloaded at `url`.
    ///
    /// Report generation can take as long as 3 hours. Repeated calls to check report status may generate a 429 response,
    /// indicating that your requests have been throttled. To retrieve reports programmatically, your application logic should
    /// institute a delay between requests. For more information,
    /// see [Retry logic with exponential backoff](concepts/rate-limiting#use-retry-logic-with-exponential-backoff).
    ///
    ///
    /// **Authorized resource type**:
    /// Global Ad Account ID, Profile ID
    ///
    /// **Parameter name**:
    /// Amazon-Advertising-API-Scope
    ///
    /// **Parameter in**:
    /// header
    ///
    /// **Requires one of these permissions**:
    /// ["advertiser_campaign_edit","advertiser_campaign_view","nemo_report_edit","nemo_report_view","reports_edit"]
    ///
    /// **Authorized resource type**:
    /// DSP Rodeo Entity ID, DSP Advertiser Account ID
    ///
    /// **Parameter name**:
    /// Amazon-Ads-AccountId
    ///
    /// **Parameter in**:
    /// header
    ///
    /// **Requires one of these permissions**:
    /// ["advertiser_campaign_edit","advertiser_campaign_view","nemo_report_edit","nemo_report_view","reports_edit","view_performance_dashboard"]
    ///
    /// - Remark: HTTP `GET /reporting/reports/{reportId}`.
    /// - Remark: Generated from `#/paths//reporting/reports/{reportId}/get(getAsyncReport)`.
    public func getAsyncReport(_ input: Operations.getAsyncReport.Input) async throws -> Operations.getAsyncReport.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getAsyncReport.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/reporting/reports/{}",
                    parameters: [
                        input.path.reportId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "Amazon-Advertising-API-ClientId",
                    value: input.headers.Amazon_hyphen_Advertising_hyphen_API_hyphen_ClientId
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "Amazon-Advertising-API-Scope",
                    value: input.headers.Amazon_hyphen_Advertising_hyphen_API_hyphen_Scope
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "Amazon-Ads-AccountId",
                    value: input.headers.Amazon_hyphen_Ads_hyphen_AccountId
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAsyncReport.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/vnd.getasyncreportresponse.v3+json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/vnd.getasyncreportresponse.v3+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AsyncReport.self,
                            from: responseBody,
                            transforming: { value in
                                .application_vnd_period_getasyncreportresponse_period_v3_plus_json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAsyncReport.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AsyncReportingError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 401:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAsyncReport.Output.Unauthorized.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AsyncReportingError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unauthorized(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAsyncReport.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AsyncReportingError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 429:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAsyncReport.Output.TooManyRequests.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AsyncReportingError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .tooManyRequests(.init(body: body))
                case 500:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAsyncReport.Output.InternalServerError.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AsyncReportingError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .internalServerError(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Deletes a report by id
    ///
    /// Deletes a report by id. Use this operation to cancel a report in a `PENDING` status.
    ///
    /// **Authorized resource type**:
    /// Global Ad Account ID, Profile ID
    ///
    /// **Parameter name**:
    /// Amazon-Advertising-API-Scope
    ///
    /// **Parameter in**:
    /// header
    ///
    /// **Requires one of these permissions**:
    /// ["advertiser_campaign_edit","advertiser_campaign_view","nemo_report_edit","nemo_report_view","reports_edit"]
    ///
    /// **Authorized resource type**:
    /// DSP Rodeo Entity ID, DSP Advertiser Account ID
    ///
    /// **Parameter name**:
    /// Amazon-Ads-AccountId
    ///
    /// **Parameter in**:
    /// header
    ///
    /// **Requires one of these permissions**:
    /// ["advertiser_campaign_edit","advertiser_campaign_view","nemo_report_edit","nemo_report_view","reports_edit","view_performance_dashboard"]
    ///
    /// - Remark: HTTP `DELETE /reporting/reports/{reportId}`.
    /// - Remark: Generated from `#/paths//reporting/reports/{reportId}/delete(deleteAsyncReport)`.
    public func deleteAsyncReport(_ input: Operations.deleteAsyncReport.Input) async throws -> Operations.deleteAsyncReport.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteAsyncReport.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/reporting/reports/{}",
                    parameters: [
                        input.path.reportId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "Amazon-Advertising-API-ClientId",
                    value: input.headers.Amazon_hyphen_Advertising_hyphen_API_hyphen_ClientId
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "Amazon-Advertising-API-Scope",
                    value: input.headers.Amazon_hyphen_Advertising_hyphen_API_hyphen_Scope
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "Amazon-Ads-AccountId",
                    value: input.headers.Amazon_hyphen_Ads_hyphen_AccountId
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.deleteAsyncReport.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/vnd.deleteasyncreportresponse.v3+json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/vnd.deleteasyncreportresponse.v3+json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DeleteAsyncReportResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .application_vnd_period_deleteasyncreportresponse_period_v3_plus_json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.deleteAsyncReport.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AsyncReportingError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 401:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.deleteAsyncReport.Output.Unauthorized.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AsyncReportingError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unauthorized(.init(body: body))
                case 403:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.deleteAsyncReport.Output.Forbidden.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AsyncReportingError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .forbidden(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.deleteAsyncReport.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AsyncReportingError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 429:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.deleteAsyncReport.Output.TooManyRequests.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AsyncReportingError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .tooManyRequests(.init(body: body))
                case 500:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.deleteAsyncReport.Output.InternalServerError.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AsyncReportingError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .internalServerError(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
}
