// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import struct Foundation.URL
@preconcurrency import struct Foundation.Data
@preconcurrency import struct Foundation.Date
#else
import struct Foundation.URL
import struct Foundation.Data
import struct Foundation.Date
#endif
import HTTPTypes
/// Profiles represent an advertiser and their account's marketplace, and are used in all subsequent API calls via a management scope, `Amazon-Advertising-API-Scope`. Reports and all entity management operations are associated with a single profile. Advertisers cannot have more than one profile for each marketplace.
///
/// Advertisers who operate in more than one marketplace (for example, Amazon.com, Amazon.co.uk, Amazon.co.jp) will have only one profile associated with each marketplace. [**See this link**](https://advertising.amazon.com/API/docs/en-us/info/api-overview#api-endpoints) for a list of marketplaces associated with each endpoint.
///
/// To retrieve your profile IDs, call the listProfiles operation, and include a valid authorization access token in the header. Use a `profileId` from the returned list as the value for the management scope (`Amazon-Advertising-API-Scope`) in the headers for subsequent API calls.
public struct Client: APIProtocol {
    /// The underlying HTTP client.
    private let client: UniversalClient
    /// Creates a new client.
    /// - Parameters:
    ///   - serverURL: The server URL that the client connects to. Any server
    ///   URLs defined in the OpenAPI document are available as static methods
    ///   on the ``Servers`` type.
    ///   - configuration: A set of configuration values for the client.
    ///   - transport: A transport that performs HTTP operations.
    ///   - middlewares: A list of middlewares to call before the transport.
    public init(
        serverURL: Foundation.URL,
        configuration: Configuration = .init(),
        transport: any ClientTransport,
        middlewares: [any ClientMiddleware] = []
    ) {
        self.client = .init(
            serverURL: serverURL,
            configuration: configuration,
            transport: transport,
            middlewares: middlewares
        )
    }
    private var converter: Converter {
        client.converter
    }
    /// Gets a list of profiles.
    ///
    /// Note that this operation does not return a response unless the current account has created at least one campaign using the advertising console.
    ///
    /// - Remark: HTTP `GET /v2/profiles`.
    /// - Remark: Generated from `#/paths//v2/profiles/get(listProfiles)`.
    public func listProfiles(_ input: Operations.listProfiles.Input) async throws -> Operations.listProfiles.Output {
        try await client.send(
            input: input,
            forOperation: Operations.listProfiles.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/profiles",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "Amazon-Advertising-API-ClientId",
                    value: input.headers.Amazon_hyphen_Advertising_hyphen_API_hyphen_ClientId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "apiProgram",
                    value: input.query.apiProgram
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "accessLevel",
                    value: input.query.accessLevel
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "profileTypeFilter",
                    value: input.query.profileTypeFilter
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "validPaymentMethodFilter",
                    value: input.query.validPaymentMethodFilter
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.listProfiles.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.Profile].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update the daily budget for one or more profiles.
    ///
    /// Note that this operation is only used for Sellers using Sponsored Products. This operation is not enabled for vendor type accounts.
    ///
    /// - Remark: HTTP `PUT /v2/profiles`.
    /// - Remark: Generated from `#/paths//v2/profiles/put(updateProfiles)`.
    public func updateProfiles(_ input: Operations.updateProfiles.Input) async throws -> Operations.updateProfiles.Output {
        try await client.send(
            input: input,
            forOperation: Operations.updateProfiles.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/profiles",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "Amazon-Advertising-API-ClientId",
                    value: input.headers.Amazon_hyphen_Advertising_hyphen_API_hyphen_ClientId
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case .none:
                    body = nil
                case let .json(value):
                    body = try converter.setOptionalRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.updateProfiles.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.ProfileResponse].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets a profile specified by identifier.
    ///
    /// This operation does not return a response unless the current account has created at least one campaign using the advertising console.
    ///
    /// - Remark: HTTP `GET /v2/profiles/{profileId}`.
    /// - Remark: Generated from `#/paths//v2/profiles/{profileId}/get(getProfileById)`.
    public func getProfileById(_ input: Operations.getProfileById.Input) async throws -> Operations.getProfileById.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getProfileById.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/profiles/{}",
                    parameters: [
                        input.path.profileId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "Amazon-Advertising-API-ClientId",
                    value: input.headers.Amazon_hyphen_Advertising_hyphen_API_hyphen_ClientId
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getProfileById.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Profile.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
}
